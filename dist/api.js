import*as e from"node:fs";async function t(e,t=!1){let o="";const i=[];return e instanceof Promise&&(e=await e),Object.values(e).forEach((e=>{const l=e.collection,c=n(l);i.push(`${l}: ${c}`),o+=`export type ${c} = {\n`,e.fields.forEach((e=>{e.meta?.interface?.startsWith("presentation-")||(o+="  ",o+=e.field.includes("-")?`"${e.field}"`:e.field,e.schema?.is_nullable&&(o+="?"),o+=": ",o+=function(e,t=!1){let o;if(e.meta?.options?.choices){const t=e.meta.options.choices.map((t=>{if("string"==typeof t)return t;if("object"==typeof t&&null!==t)return t.value;throw new Error("Unhandled choices structure: "+JSON.stringify(e,null,2))}));o=[...new Set(t)].map((e=>null===e?"null":'"'+e.replaceAll("\\","\\\\")+'"')).join(" | ")}else o=["integer","bigInteger","float","decimal"].includes(e.type)?"number":["boolean"].includes(e.type)?"boolean":["json","csv"].includes(e.type)?"unknown":"string";if(e.relation){const i="string | number",l=e.relation.collection?n(e.relation.collection):"any";o="many"===e.relation.type?`(${i})[] ${t?"&":"|"} (${l})[]`:`${i} ${t?"&":"|"} ${l}`}return o}(e,t),o+=";\n")})),o+="};\n\n"})),o+="export type GeneratedDirectusTypes = {\n"+i.map((e=>`  ${e};`)).join("\n")+"\n};",o+="\n",o}function n(e){return e.split(" ").flatMap((e=>e.split("_"))).flatMap((e=>e.split("-"))).map((e=>e.charAt(0).toUpperCase()+e.slice(1))).join("")}async function o(e,t,n){const o={};return e.sort(((e,t)=>e.collection.localeCompare(t.collection))).forEach((e=>o[e.collection]={...e,fields:[]})),t.sort(((e,t)=>e.field.localeCompare(t.field))).forEach((e=>{if(!o[e.collection])return t=`${e.collection} not found`,void console.warn(`%c[directus-extension-generate-types]%c\n${t}`,"font-weight: bold;");var t;o[e.collection].fields.push(e)})),Object.keys(o).forEach((e=>{0===o[e].fields.length&&delete o[e]})),n.forEach((e=>{const t=o[e.meta.one_collection]?.fields.find((t=>t.field===e.meta.one_field)),n=o[e.meta.many_collection]?.fields.find((t=>t.field===e.meta.many_field));t&&(t.relation={type:"many",collection:e.meta.many_collection}),n&&(n.relation={type:"one",collection:e.meta.one_collection})})),o}var i=async({action:e},n)=>{const{services:{CollectionsService:i,FieldsService:a,RelationsService:s},env:r,logger:f,getSchema:d}=n;let p=r.GENERATE_TYPES_SYNCED_TS_FILES;if(null==p||0===p.length)return void f.info("No target file defined to automatically sync TypeScript types");Array.isArray(p)||(p=[p]);const u=async()=>{const e=await d(),n=new i({schema:e}),r=await n.readByQuery(),u=new a({schema:e}),y=await u.readAll(),m=new s({schema:e}),h=await m.readAll();t(await o(r,y,h),!1).then((e=>{p.forEach((t=>{l("./",t,c+e),f.info(`Types synced into ${t}`)}))}))};u();const y=async()=>{u()};e("collections.create",y),e("collections.update",y),e("collections.delete",y),e("fields.create",y),e("fields.update",y),e("fields.delete",y),e("relations.create",y),e("relations.update",y),e("relations.delete",y)};const l=(t,n,o)=>{try{e.mkdirSync(t,{recursive:!0})}catch(e){if("EEXIST"!=e.code)throw e}e.writeFileSync(`${t}/${n}`,o)},c="/*\n * This file is generated by 'directus-extensions-generate-types' script.\n * Do not edit manually.\n */\n",a=[{name:"extension-hook.sync-ts-files",config:i}],s=[],r=[];export{s as endpoints,a as hooks,r as operations};
