import*as e from"node:fs";async function n(e,n=!1){let o="";const l=[];return e instanceof Promise&&(e=await e),Object.values(e).forEach((e=>{const i=e.collection,c=t(i);l.push(`${i}: ${c}`),o+=`export type ${c} = {\n`,e.fields.forEach((e=>{var l,i,c;(null==(i=null==(l=e.meta)?void 0:l.interface)?void 0:i.startsWith("presentation-"))||(o+="  ",o+=e.field.includes("-")?`"${e.field}"`:e.field,(null==(c=e.schema)?void 0:c.is_nullable)&&(o+="?"),o+=": ",o+=function(e,n=!1){let o;e.relation?(o="number",o+=n?" & ":" | ",o+=e.relation.collection?t(e.relation.collection):"any","many"===e.relation.type&&(o=`(${o})[]`)):o=["integer","bigInteger","float","decimal"].includes(e.type)?"number":["boolean"].includes(e.type)?"boolean":["json","csv"].includes(e.type)?"unknown":"string";return o}(e,n),o+=";\n")})),o+="};\n\n"})),o+="export type GeneratedDirectusTypes = {\n"+l.map((e=>`  ${e};`)).join("\n")+"\n};",o+="\n",o}function t(e){return e.split(" ").flatMap((e=>e.split("_"))).flatMap((e=>e.split("-"))).map((e=>e.charAt(0).toUpperCase()+e.slice(1))).join("")}async function o(e,n,t){const o={};return e.sort(((e,n)=>e.collection.localeCompare(n.collection))).forEach((e=>o[e.collection]={...e,fields:[]})),n.sort(((e,n)=>e.field.localeCompare(n.field))).forEach((e=>{if(!o[e.collection])return n=`${e.collection} not found`,void console.warn(`%c[directus-extension-generate-types]%c\n${n}`,"font-weight: bold;");var n;o[e.collection].fields.push(e)})),Object.keys(o).forEach((e=>{0===o[e].fields.length&&delete o[e]})),t.forEach((e=>{var n,t;const l=null==(n=o[e.meta.one_collection])?void 0:n.fields.find((n=>n.field===e.meta.one_field)),i=null==(t=o[e.meta.many_collection])?void 0:t.fields.find((n=>n.field===e.meta.many_field));l&&(l.relation={type:"many",collection:e.meta.many_collection}),i&&(i.relation={type:"one",collection:e.meta.one_collection})})),o}var l=async({action:e},t)=>{const{services:{CollectionsService:l,FieldsService:a,RelationsService:s},env:r,logger:d,getSchema:f}=t;let y=r.GENERATE_TYPES_SYNCED_TS_FILES;if(null==y||0===y.length)return void d.info("No target file defined to automatically sync TypeScript types");Array.isArray(y)||(y=[y]);const u=async()=>{(async()=>{const e=await f(),t=new l({schema:e}),r=await t.readByQuery(),u=new a({schema:e}),p=await u.readAll(),m=new s({schema:e}),h=await m.readAll();n(await o(r,p,h),!1).then((e=>{y.forEach((n=>{i("./",n,c+e),d.info(`Types synced into ${n}`)}))}))})()};e("collections.create",u),e("collections.update",u),e("collections.delete",u),e("fields.create",u),e("fields.update",u),e("fields.delete",u),e("relations.create",u),e("relations.update",u),e("relations.delete",u)};const i=(n,t,o)=>{try{e.mkdirSync(n,{recursive:!0})}catch(e){if("EEXIST"!=e.code)throw e}e.writeFileSync(`${n}/${t}`,o)},c="/*\n * This file is generated by 'directus-extensions-generate-types' script.\n * Do not edit manually.\n */\n",a=[{name:"extension-hook.sync-ts-files",config:l}],s=[],r=[];export{s as endpoints,a as hooks,r as operations};
